"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t,r=require("rxjs"),e=require("rxjs/operators");
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function n(t,r){var e="function"==typeof Symbol&&t[Symbol.iterator];if(!e)return t;var n,i,o=e.call(t),a=[];try{for(;(void 0===r||r-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(t){i={error:t}}finally{try{n&&!n.done&&(e=o.return)&&e.call(o)}finally{if(i)throw i.error}}return a}function i(){for(var t=[],r=0;r<arguments.length;r++)t=t.concat(n(arguments[r]));return t}(t=exports.FlattenOperator||(exports.FlattenOperator={})).switchMap="switchMap",t.mergeMap="mergeMap",t.concatMap="concatMap",t.exhaustMap="exhaustMap";var o=function(t){return null!==t&&"object"==typeof t},a=r.pipe(e.catchError((function(t){return r.of(t)}))),u=function(t){return t.pipe(a)},c=function(t){return r.isObservable(t)?t:t instanceof Promise?r.from(t):r.of(t)};function p(t){var r=n(t,3),o=r[0],a=r[1],u=r[2];return e.scan((function(t,r){return u.length>0?u.reduce((function(t,r){return function(){for(var e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];return t(r.apply(void 0,i(e)))}}))(a)(t,r):a(t,r)}),o)}var f={switchMap:e.switchMap,mergeMap:e.mergeMap,concatMap:e.concatMap,exhaustMap:e.exhaustMap};
/**
 * Reactive state container based on RxJS (https://rxjs.dev/)
 *
 * @class AsyncStore<State, ActionsUnion>
 *
 * @type State - application state interface
 * @type ActionsUnion - type union of all the actions
 */
var s=
/**
     * Default configuration
     *
     * @param {Object} config
     *  {
     *     reducer$: of(reducer({})),
     *     actionStream$: EMPTY, // if not defined, no actions will be dispatched in the store
     *     initialState$: of({}),
     *     middleware$: of([]),
     *     destroy$: NEVER // if not defined, the state subscription will live forever
     *  }
     *
     * @param {Object} options
     *  {
     *     actionFop: FlattenOps.concatMap, // Flatten operator for actions's stream.
     *     stateFop: FlattenOps.switchMap // Flatten operator for state's stream.
     *     windowTime: undefined //Maximum time length of the replay buffer in milliseconds.
     *     bufferSize: 1 //Maximum element count of the replay buffer.
     *  }
     */
function(t,n){var i=this;this.config=t,this.options=n,this._dispatch$=new r.Subject,this.dispatch=function(t){i._dispatch$.next(t)};var s=function(t,n,i){void 0===t&&(t={}),void 0===n&&(n={});var p=t&&t.reducer$&&t.reducer$.pipe(a)||r.of((function(t,r){return t})),s=new r.Subject,l=(t&&t.initialState$&&t.initialState$.pipe(a)||r.of({})).pipe(e.share()),h=t&&t.middleware$&&t.middleware$.pipe(a)||r.of([]),d=t&&t.destroy$&&t.destroy$.pipe(a)||r.NEVER,$=f[n&&n.actionFlatOp||exports.FlattenOperator.concatMap],m=f[n&&n.stateFlatOp||exports.FlattenOperator.switchMap],x=n&&n.bufferSize||1,S=n&&n.windowTime;return{reducer$:p,actions$:s,actionStream$:function(n){return r.merge(t&&t.actionStream$&&t.actionStream$.pipe(a)||r.EMPTY,i).pipe(e.filter(o),e.map(c),$(u),e.tap(s),n,e.map(c))},initialState$:l,middleware$:h,destroy$:d,flattenState$:function(t){return t.pipe(m(u),e.map(c),m(u))},shareReplayConfig:{refCount:!1,bufferSize:x,windowTime:S}}}(this.config,this.options,this._dispatch$),l=s.reducer$,h=s.actions$,d=s.actionStream$,$=s.middleware$,m=s.initialState$,x=s.destroy$,S=s.flattenState$,v=s.shareReplayConfig;this.state$=r.combineLatest(m,l,$).pipe(e.map(p),e.concatMap(d),e.startWith(m),S,e.takeUntil(x),e.shareReplay(v)),this.state$.subscribe(),this.actions$=h.pipe(e.shareReplay(v))};exports.Store=s,exports.catchErr=a,exports.createStore=function(t,r){return void 0===t&&(t={}),void 0===r&&(r={}),new s(t,r)}
/**
 *
 * @param mapFn - a function to map a state with
 * @returns {MiddlewareFn} MiddlewareFn<State>
 *
 * PS - previous state
 * NS - next state
 */,exports.filterA=function(t){return function(r){return function(e,n){return t(n)?r(e,n):e}}},exports.filterNS=function(t){return function(r){return function(e,n){var i=r(e,n);return t(i)?i:e}}},exports.filterPS=function(t){return function(r){return function(e,n){return t(e)?r(e,n):e}}},exports.flatCatch=u,exports.mapA=function(t){return function(r){return function(e,n){return r(e,t(n))}}},exports.mapNS=function(t){return function(r){return function(e,n){return t(r(e,n))}}},exports.mapPS=function(t){return function(r){return function(e,n){return r(t(e),n)}}},exports.mapToObservable=c,exports.reduceA=function(t){return function(r){return function(e,n){return r(e,t(e,n))}}},exports.reduceNS=function(t){return function(r){return function(e,n){return t(r(e,n),n)}}},exports.reducePS=function(t){return function(r){return function(e,n){return r(t(e,n),n)}}};
